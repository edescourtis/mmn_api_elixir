# NOTE: This class is auto generated by the swagger code generator program.
# https://github.com/swagger-api/swagger-codegen.git
# Do not edit the class manually.

defmodule MmnApi.Api.Broadcast do
  @moduledoc """
  API calls for all endpoints tagged `Broadcast`.
  """

  alias MmnApi.Connection
  import MmnApi.RequestBuilder


  @doc """
  Perform an action on a broadcast
  Action is required. Only SEND and VALIDATE_AND_SEND are supported. Difference is SEND fails with broadcast errors (e.g. a subsystem is down, or a media without recipients), while VALIDATE_AND_SEND fails also if validation warnings are present (for example: broadcast parameters were missing when validating first few recipients).    See Create broadcast API call for additional documentation about the broadcast workflow.

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - bid (Integer): The broadcast indentifier
  - action (String): Broadcast action
  - opts (KeywordList): [optional] Optional parameters
    - :body (SendBroadcastActionParameterBody): broadcast parameters (optional)

  ## Returns

  {:ok, %MmnApi.Model.Report{}} on success
  {:error, info} on failure
  """
  @spec broadcast_action_json(Tesla.Env.client, Integer.t, String.t, keyword()) :: {:ok, MmnApi.Model.Report.t} | {:error, Tesla.Env.t}
  def broadcast_action_json(connection, bid, action, opts \\ []) do
    optional_params = %{
      :"body" => :body
    }
    %{}
    |> method(:post)
    |> url("/broadcasts/#{bid}")
    |> add_param(:query, :"action", action)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%MmnApi.Model.Report{})
  end

  @doc """
  Perform an action on a broadcast
  Action is required. Only SEND and VALIDATE_AND_SEND are supported. Difference is SEND fails with broadcast errors (e.g. a subsystem is down, or a media without recipients), while VALIDATE_AND_SEND fails also if validation warnings are present (for example: broadcast parameters were missing when validating first few recipients).    See Create broadcast API call for additional documentation about the broadcast workflow.

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - code (String): The broadcast code
  - action (String): Broadcast action
  - opts (KeywordList): [optional] Optional parameters
    - :body (SendBroadcastActionParameterBody): broadcast parameters

  ## Returns

  {:ok, %MmnApi.Model.Report{}} on success
  {:error, info} on failure
  """
  @spec broadcast_action_json_by_code(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, MmnApi.Model.Report.t} | {:error, Tesla.Env.t}
  def broadcast_action_json_by_code(connection, code, action, opts \\ []) do
    optional_params = %{
      :"body" => :body
    }
    %{}
    |> method(:post)
    |> url("/broadcasts/codes/#{code}")
    |> add_param(:query, :"action", action)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%MmnApi.Model.Report{})
  end

  @doc """
  Create a broadcast
    # Broadcast Messages  The API supports creating broadcasts containing textual messages to many different mediums, including text-to-speech for rendering text to an audio message for voice and paging broadcasts. To simplify the completion of text fields by a user, creating broadcasts using the API will share text fields across mediums.    For example, a desktop alert broadcast will require a subject and a message body, similar to a message for an email broadcast, so a broadcast containing both email and desktop alert will use the same subject and message body fields for their content.  There are three types of text fields used for message content:  1. a subject line  1. a short message body  1. a long message body    Depending on the medium, not all of these text fields are required. For example, SMS will only use the short message body for its content. The following table summarizes, which text fields are required to send a broadcast using a given medium:    | Mediums                                 | subject     | textShortMessage | textLongMessage       |  | --------------------------------------  | ----        | ----             | ----                  |  | EMAIL                                   | X           |                  | X                     |  | DESKTOP                                 | X           |                  | X                     |  | IP_PHONE                                | X           |                  | X                     |  | RECORDED_PAGING (with TTS)              |             |                  | X                     |  | SMS                                     |             | X                |                       |  | VOICE (with TTS)                        |             |                  | X                     |    ## Audio Messages  Voice and Paging mediums can use either TTS (Text to Speech, if licensed and configured on the MMN server), or an externally prepared audio file.     Use API parameter &#39;audioURI&#39; to specify an audio file location. The API offers two delivery mechanisms:  1. Audio file **local** on the MMN server (&#x60;&#39;audioURI.remote&#39;&#x3D;false&#x60;). (*How to get the file to the MMN server?* An external system can use SFTP or FTP to copy the file, see user &#39;cupload&#39; in the Admin Guide.) For example:  &#x60;&#x60;&#x60;  curl -u apiuser:secret -i -X POST https://mmn.mycompany.com/blazecast/api/broadcasts -H &#39;accept: application/json&#39; -H &#39;content-type: application/json&#39;\\  -d &#39;{\&quot;title\&quot;:\&quot;Voice API Local file\&quot;, \&quot;recipients\&quot;:[{\&quot;contact_data\&quot;:\&quot;1001\&quot;}],\&quot;mediums\&quot;:[\&quot;VOICE\&quot;], \\\&quot;audioURI\&quot;:{\&quot;httpURI\&quot;:\&quot;/home/cupload/myaudiofile.wav\&quot;,\&quot;remote\&quot;:false},\&quot;saved\&quot;:true}&#39;  &#x60;&#x60;&#x60;  2. **Remote** audio file (&#x60;&#39;audioURI.remote&#39;&#x3D;true&#x60;). The file is retrieved via http or https protocol, with optional authentication. Here is a simple example:  &#x60;&#x60;&#x60;  curl -u apiuser:secret -i -X POST https://mmn.mycompany.com/blazecast/api/broadcasts -H &#39;accept: application/json&#39; -H &#39;content-type: application/json&#39;\\  -d &#39;{\&quot;title\&quot;:\&quot;Voice API Remote file\&quot;, \&quot;recipients\&quot;:[{\&quot;contact_data\&quot;:\&quot;1001\&quot;}],\&quot;mediums\&quot;:[\&quot;VOICE\&quot;],\\ \&quot;audioURI\&quot;:{\&quot;httpURI\&quot;:\&quot;http://fileserver.mycompany.com/recordedMessage.wav\&quot;,\&quot;remote\&quot;:true,\&quot;method\&quot;:\&quot;GET\&quot;,\&quot;scheme\&quot;:\&quot;NONE\&quot;},\&quot;saved\&quot;:true}&#39;  &#x60;&#x60;&#x60;   Notes:    * Parameter \&quot;httpURI\&quot; is interpreted on the MMN server, make sure the host name is resolvable there.  * TTS has precedence over audio files. If both &#x60;\&quot;options\&quot;:[\&quot;TTS\&quot;]&#x60; and &#x60;\&quot;audioURI\&quot;&#x60; are specified, then audio is downloaded but ignored.      MMN requires audio files to be in a specific format:    |             |                |  | ---------   | ---            |  | File format | WAV            |  | File size   | less than 5 MB |  | Bit rate    | 128 Kbps       |  | Sample size | 16 bits        |  | Channels    | 1 (monophonic) |  | Sample rate | 8 KHz          |  | Format      | PCM            |  If the file does not conform to the specification, broadcast creation may succeed, but sending of broadcast would fail. Always test!  ___    

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :body (BroadcastForm): A broadcast form

  ## Returns

  {:ok, %MmnApi.Model.Broadcast{}} on success
  {:error, info} on failure
  """
  @spec create_broadcast(Tesla.Env.client, keyword()) :: {:ok, MmnApi.Model.Broadcast.t} | {:error, Tesla.Env.t}
  def create_broadcast(connection, opts \\ []) do
    optional_params = %{
      :"body" => :body
    }
    %{}
    |> method(:post)
    |> url("/broadcasts")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%MmnApi.Model.Broadcast{})
  end

  @doc """
  Get a broadcast by identifier
  

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - bid (Integer): The broadcast identifier
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %MmnApi.Model.Broadcast{}} on success
  {:error, info} on failure
  """
  @spec get_broadcast(Tesla.Env.client, Integer.t, keyword()) :: {:ok, MmnApi.Model.Broadcast.t} | {:error, Tesla.Env.t}
  def get_broadcast(connection, bid, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/broadcasts/#{bid}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%MmnApi.Model.Broadcast{})
  end

  @doc """
  Get a broadcast by code
  

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - code (String): 
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %MmnApi.Model.Broadcast{}} on success
  {:error, info} on failure
  """
  @spec get_broadcast_by_code(Tesla.Env.client, String.t, keyword()) :: {:ok, MmnApi.Model.Broadcast.t} | {:error, Tesla.Env.t}
  def get_broadcast_by_code(connection, code, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/broadcasts/codes/#{code}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(%MmnApi.Model.Broadcast{})
  end

  @doc """
  Get a list of broadcasts that use a broadcast code
  Returns a list of broadcasts, sorted by codes in alphabetical order.        # Overview  Sending a broadcast typically requires two API calls:  1. Get reference to a broadcast, which you can do one of two ways:     * Create a broadcast, which allows you to specify the message, recipients, and options from scratch.     * Retrieve a list of broadcasts.  1. Use the broadcast ID retrieved from either one of the previous two calls, and use it to send the broadcast.     ___    # Triggering Broadcasts from a 3rd Party System  One of the useful things this API allows you to do is trigger a broadcast through MMN from a 3rd-party system.    __Example__: Trigger different broadcasts from a security system when an intruder is detected:  * Broadcast that calls each person on the security team and conferences them together.  * Broadcast that sends a page to select speakers.  * Broadcast that calls the security staff, and at the same time sends a PC alert to PCs in the security office.  You can either set up broadcasts in MMN ahead of time to be triggered by the 3rd party system, or have the 3rd-party system create a broadcast from scratch and send it to MMN when needed.    ## Set up broadcast in MMN via web UI  1. Log in to MMN UI.  1. Create New Broadcast in MMN: type and/or record message, select communication mediums, and select recipients.  1. Give broadcast a name and save without sending.  1. Give the broadcast a broadcast code.  Create a separate broadcast for each type of distinct scenario, e.g. when different people need to be contacted, or different options need to be set.    ## On Event Trigger  1. Event trigger from third-party system calls MMN API to send a broadcast. Broadcast can be specified in one of following ways:      * Using a broadcast ID, e.g. by first retrieving a list of broadcasts and choosing the desired one.      * Using a broadcast code. (Note: Code provides more flexibility than ID: Broadcasts are immutable, i.e. a new ID is assigned to a broadcast that was modified. The code can be simply re-assigned to the updated broadcast.)      * Creating a broadcast from scratch.  1. Launches pre-configured broadcast using its broadcast code or ID  1. MMN sends voice and/or text notification to specified devices  1. Users/devices receive call/page/text message  1. Users acknowledge notifications  1. Users join dial-out conference (if specified as part of broadcast)  1. Acknowledgements are reported in real-time on MMN web UI  

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, [%BroadcastSummary{}, ...]} on success
  {:error, info} on failure
  """
  @spec get_broadcast_list(Tesla.Env.client, keyword()) :: {:ok, list(MmnApi.Model.BroadcastSummary.t)} | {:error, Tesla.Env.t}
  def get_broadcast_list(connection, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/broadcasts")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode([%MmnApi.Model.BroadcastSummary{}])
  end

  @doc """
  Get a list of instant broadcasts
  Returns a list of broadcasts selected for quick launch.   *Sorting order: emergency first, normal priority second. Each priority is sorted by broadcast title.*

  ## Parameters

  - connection (MmnApi.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, [%BroadcastSummary{}, ...]} on success
  {:error, info} on failure
  """
  @spec get_instant_broadcasts(Tesla.Env.client, keyword()) :: {:ok, list(MmnApi.Model.BroadcastSummary.t)} | {:error, Tesla.Env.t}
  def get_instant_broadcasts(connection, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/broadcasts/instant")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode([%MmnApi.Model.BroadcastSummary{}])
  end
end
